# RSA 4/4
Crypto

## Challenge 

DESCRIPTION
Someone sent me this stupid encryption thing which doesn't even work half the time.

Today, I managed to capture all its output when it just happened to work.

Author: prokarius

ATTACHED FILES
generator.py
out.txt

## Solution

From out.txt

	n = 1256656480120450597072003081650664247724680264297536167141726306997142058813860712447498826449451514352875011768202001668178501530482872870615464922095824146502601180079982667001473444407850861123511536903340611829437862912575888515400255728038035391942435700006309694619049809051715181593028933225306263279801681907232318764723173740565723029660057614708655761208626229572919039715738878236340790655662803118743086409128997507998047948092769887723393691045315067
	e = 8191
	c = 343292776895766888536083165351571730259730847918073317720388964013126703879113072037337018621254488725392807393703102067179576752962271235265003850560159896570099387748975815369717320538910649490423861836151069785424337613650101432092061245157827793583837044758877052640267613461602073836793757063314846174582455147237978374748983176551367801974611709632446290708494931592678353919903470747849541699038339713277417890971635019860750612131243547422949513961547785

From generator.py, this is suspicious

        # Set up decryption keys, do the mod inverse thing
        # TODO: Check if this code is working correctly
        q = modinv(e, p)
        tot = (p-1)*(q-1)
        d = modinv(e, tot)

RSA theory

	e*d = 1 mod phi, where d = modinv(e, phi) = mod(1/e, phi)

workings

	q = modinv(e, p)
	q = mod(1/e, p)

	N = pq = p * mod(1/e, p)

	N (mod p) = p/e (mod p) = 1/e (mod p)

	pq == p * 1/e
	qe = kp

	pqe = kpp
	Ne = k * p^2




	Ne = 1 (mod p)

## Flag

	?